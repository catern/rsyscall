"""A setuptools entrypoint to store dependencies on Nix packages at build-time

setuptools automatically registers this entry-point when you have the
nixdeps module on your PYTHONPATH. Then you can provide the following
keyword argument to `setup`:
```
nixdeps = {'mypkg._whatever': ['hello', 'goodbye']}
```
and then, if you have dependencies on the 'hello' and 'goodbye' Nix
packages, after a setuptools build, you will be able to use:
```
import mypkg._whatever.hello as hello
hello.closure
import mypkg._whatever.goodbye as goodbye
goodbye.closure
```

For this to work, you need to add "hello" and "goodbye" to
exportReferencesGraph, like this:
```
buildPythonPackage {
  exportReferencesGraph = [
    "hello" pkgs.hello
    "goodbye" pkgs.goodbye
  ];
}
```
Otherwise, we can't get the closure.

"""
import setuptools
import functools
import os
import os.path
import typing as t
from pathlib import Path
from distutils import log
import subprocess

__all__ = [
    'nixdeps',
]

def write_python(output_path: Path, path: str, closure: t.List[str]) -> None:
    with open(output_path, 'w') as f:
        f.write('''# Generated by the "nixdeps" line in setup.py
import nixdeps
import pathlib
''')
        f.write(f'closure = nixdeps.PackageClosure(pathlib.Path("{path}"), [\n')
        for clsr_path in closure:
            f.write(f'    "{clsr_path}",\n')
        f.write('])\n')

def write_init(output: Path) -> None:
    with output.open('w') as f:
        pass

def get_dep_with_nix_store(dep: str, path: str) -> t.List[str]:
    # use nix-store to dump the closure
    closure_text = subprocess.run(["nix-store", "--query", "--requisites", path],
                                  capture_output=True, check=True).stdout
    closure = [line.decode() for line in closure_text.split()]
    return closure

def parse_references_graph(lines: t.List[str]) -> t.Dict[str, t.List[str]]:
    it = iter(lines)
    ret: t.Dict[str, t.List[str]] = {}
    while True:
        try:
            path = next(it)
        except StopIteration:
            return ret
        number = int(next(it))
        refs = [next(it) for _ in range(number)]
        ret[path] = refs

def closure_of(path: str, refs: t.Dict[str, t.List[str]]) -> t.Set[str]:
    return frozenset().union(*[
        {path} if ref == path else closure_of(ref, refs)
        for ref in refs[path]])

def get_dep_from_exported_graph(nix_build_top: Path, dep: str, path: str) -> t.List[str]:
    # we're in a real build, use output of exportReferencesGraph
    closure_path = nix_build_top/dep
    with open(closure_path, 'r') as f:
        raw_db = f.read()
    lines = raw_db.split()
    refs = parse_references_graph(lines)
    return list(closure_of(path, refs))

def get_fake_dep(dep: str, path: str) -> t.List[str]:
    # just fake it
    log.info("making up fake dep for %s" % dep)
    return ["/dev/null/" + dep + "/closure"]

def build_deps_module(self, output_dir: Path, deps: t.List[str]) -> None:
    "Write out to `output_dir` the .py files containing the specification for `deps`"
    if 'exportReferencesGraph' in os.environ:
        envvar = os.environ['exportReferencesGraph'].split(' ')
        exportReferencesGraph = dict(zip(envvar[::2], envvar[1::2]))
        if 'IN_NIX_SHELL' in os.environ:
            get_dep = get_dep_with_nix_store
        else:
            get_dep = functools.partial(get_dep_from_exported_graph, Path(os.environ['NIX_BUILD_TOP']))
    else:
        exportReferencesGraph = {
            dep: "/dev/null/" + dep
            for dep in deps
        }
        get_dep = get_fake_dep
    log.info("generating Nix deps module in %s" % output_dir)
    self.mkpath(str(output_dir))
    self.execute(write_init, [output_dir/"__init__.py"])
    for dep in deps:
        log.info("writing Nix dep %s" % dep)
        path = exportReferencesGraph[dep]
        closure = get_dep(dep, path)
        self.execute(write_python, [output_dir/(dep + '.py'), path, closure])

def add_deps_module(dist, module_name: str, deps: t.List[str]) -> None:
    # This function is heavily cribbed from cffi's setuptools_ext.py
    from setuptools.command.build_py import build_py
    from setuptools.command.build_ext import build_ext

    def generate_mod(self, outdir: str) -> None:
        build_deps_module(self, Path(outdir), deps)

    base_class = dist.cmdclass.get('build_py', build_py)
    class build_py_make_mod(base_class):
        def run(self):
            base_class.run(self)
            module_path = module_name.split('.')
            output_path = os.path.join(self.build_lib, *module_path)
            generate_mod(self, output_path)
    dist.cmdclass['build_py'] = build_py_make_mod

    # distutils and setuptools have no notion I could find of a
    # generated python module.  If we don't add module_name to
    # dist.py_modules, then things mostly work but there are some
    # combination of options (--root and --record) that will miss
    # the module.  So we add it here, which gives a few apparently
    # harmless warnings about not finding the file outside the
    # build directory.
    if dist.py_modules is None:
        dist.py_modules = []
    dist.py_modules.append(module_name)

    # the following is only for "build_ext -i"
    base_class_2 = dist.cmdclass.get('build_ext', build_ext)
    class build_ext_make_mod(base_class_2):
        def run(self):
            base_class_2.run(self)
            if self.inplace:
                build_py = self.get_finalized_command('build_py')
                output_path = build_py.get_package_dir(module_name)
                generate_mod(self, output_path)
    dist.cmdclass['build_ext'] = build_ext_make_mod

def nixdeps(dist, attr: str, value) -> None:
    "The main setuptools entry point. Automatically registered with setuptools via distutils.setup_keywords"
    assert attr == 'nixdeps'
    for module_name, deps in value.items():
        add_deps_module(dist, module_name, deps)
