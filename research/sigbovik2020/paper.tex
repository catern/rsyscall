\documentclass[sigplan]{acmart}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[SIGBOVIK 2020]{SIGBOVIK}{April 2020}{Pittsburgh, PA USA}
\acmYear{2020}
\copyrightyear{2020}


%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

% Document starts
\begin{document}

% Title portion. Note the short title for running heads
\title[Type-directed decompilation of shell scripts]{Type-directed decompilation of shell scripts}

\author{Spencer Baugh}
\affiliation{%
  \institution{University of Carcosa}
  \streetaddress{104 Lost Beach}
  \city{Carcaso}
  \country{Hyades}}
\email{first.last@gmail.com}
\author{Dougal Pugson}
\affiliation{%
  \institution{Pugson's C++ Crypt LLC}
  \city{New York}
  \country{USA}
}
\email{dougalpugson@gmail.com}

\begin{abstract}
Maintenance shell programmers are often faced with inscrutable shell scripts without human-readable source code.
We apply techniques pioneered by the type-directed partial evaluation community
to create a decompiler which can take an executable shell script and recover its original source code. 
This technique has surprising generality,
and our decompiler can also be used as a pretty-printer, or in general,
as a compiler from any language into shell.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006.10011050.10010517</concept_id>
       <concept_desc>Software and its engineering~Scripting languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011041</concept_id>
       <concept_desc>Software and its engineering~Compilers</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011073</concept_id>
       <concept_desc>Software and its engineering~Software maintenance tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Scripting languages}
\ccsdesc[500]{Software and its engineering~Compilers}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Software and its engineering~Software maintenance tools}

\keywords{Partial evaluation, type systems, shell scripting}

\maketitle

\section{Introduction}\label{introduction}
Among its many beneficial properties, shell has a unique feature:
The language automatically compiles itself as it is written.
Immediately after a shell script is typed into a computer and saved into a file,
it is transformed into a compiled form which is unreadable by humans.
\footnote{Use of the authors' previous work on delimited continuations in bash, \cite{bashcc}, seems to accelerate this process.}
Such a script can be immediately used for all your most important financial data, medical procedures, etc.,
while you are safe in the knowledge that no-one can read your important proprietary shell scripts.

Unfortunately, sometimes such scripts might exhibit minor bugs.
Since these executable files that are leftover from the process of shell scripting are unreadable garbage,
maintenance programmers are often forced to rewrite from scratch.
Sometimes, very brave programmers will try open one of these old, buggy "shell script files",
but generally they are instantly turned to stone upon seeing the inscrutable contents.
And since shell is so convenient, typically the original programmer is long gone - probably retired early.

Our contribution in this paper is a decompiler for these files,
which is able to recover the original source code.
This source code can then be viewed by the maintenance programmer,
to help them reimplement the script in their non-shell language of choice.

As outlined in our previous work, \cite{bashcc},
the Unix shell is closely historically related to functional programming.
Thus it should be no surprise that we are able to transplant techniques
from the functional programming community, to the shell,
in the tradition of \cite{frankenstein}.

In this case, we use partial evaluation techniques to achieve our goal.
As described in \cite{oleg}, as citing \cite{danvy}, as blowing the minds of undergrads everywhere,
sufficiently general partial evaluation techniques
can be applied to "reify" a compiled program and recover the program source code,
under the constraints that the program 1. has a type and 2. terminates.
Pretty easy constraints, I think we can make that happen for bash!

As a more approachable introduction (note that "more approachable" doesn't mean "approachable"),
these techniques can be compared to tagless-final-style techniques.
Decompilation of a typed, compiled program is essentially identical to pretty-printing of a tagless-final-style term.
The magic is that any typed, closed program can be treated as a TFS term.

Our paper is organized in some number of sections.
Section \ref{introduction} contains an introduction and a description of the organization of the paper.
Section \ref{theory} contains a exploration of the requirements for applying these techniques,
and establishes their firm grounding in theory.
Section \ref{applications} demonstrates several applications.
Section \ref{implementation} gives an overview of the implementation.
Section \ref{conclusion} concludes the paper, discusses future work, and affirms that this was the right thing to do.
\section{Theory}\label{theory}

As mentioned above and in \cite{danvy},
we have two requirements to apply type-directed partial evaluation:
The program must be typed and must terminate.
\subsection{Typed}
What is the type of a shell script?
Well, a shell script takes the PATH environment variable,
and runs commands (identified by strings) out of PATH,
each of which has some side effects.
A shell script doesn't return anything, it just has side effects,
so let's say that its output type is unit.

So that means a shell script has type $path -> unit$,
where $path$ is $(str, [str]) -> unit$.

Then in total, a shell script has type $((str, [str]) -> unit) -> unit$.

We can confirm this is correct by applying double negation elimination
\footnote{DNE is an axiom because this paper is unintuitive.}
which shows us that shell scripts have type $(str, [str])$.
This is correct because a shell script is indeed a bunch of strings.

Let's be a little more specific with our type, though, and model each executable as a function.
So then the type of PATH is $(str -> ([str] -> unit))$,
and the type of a shell script is then $(str -> ([str] -> unit)) -> unit$

For now, just think of a shell script as taking PATH and running commands out of it.
\subsection{Termination}
Termination, on the other hand, is a much harder problem than assigning a strict static type to shell scripts.
This is because of the presence of the dreaded D-wait in Unix.
A process can get into an uninterruptible state when making a filesystem request,
and just hang forever, ignoring all signals, including SIGKILL.
This is really annoying for people developing filesystems, which we had to do for this paper,
so we want to complain about it here.

Nevertheless, if the program hangs, this issue can be solved by simply mashing Ctrl-C.
Even D-wait can be solved by throwing the computer out the window
(assuming a sufficiently portable computer, and great enough height for it to be destroyed on impact).

So termination is ultimately not a problem either.
\subsection{Background}
In brief, the principle of the technique we will be applying is this:
A closed, abstract function,
which takes in other functions and combines them through application in some way to eventually return a result,
can be passed functions which, instead of performing actual operations and returning real results,
take ASTs and return ASTs.

For example, a parameter with type $(a, a) -> a$,
which might normally be addition of two integers or something,
can be passed at the specific type $(ast, ast) -> ast$,
and be implemented as $\lambda x. \lambda y. Plus (x, y)$
where $Plus$ is some data-type constructor.

A shell script's single argument (in our model) is the PATH environment variable.
\footnote{This has sufficiently abstract types, since everything is a string, so we don't know what anything is.}
We will pass in a PATH which, when an executable name is looked up in it,
returns the executables (functions) of our choice.
These executables will in turn, when executed,
construct an AST instead of actually doing anything.
\section{Applications}\label{applications}
Let's demonstrate our tool before getting to the actually interesting part.

\subsection{Decompiling bash}
Suppose we save the following shell script to a file and mark it executable,
which instantaneously makes it unreadable.
\begin{lstlisting}[language=bash]
ls; which ls
stat /
foo|bar
\end{lstlisting}
Nevertheless our decompiler can run on the script and produces the following output:
\begin{lstlisting}[language=bash]
ls
which ls
stat /
foo | bar
\end{lstlisting}
As you can see, our decompiler even pretty-prints the shell script.
\subsection{Decompiling arbitrary executables}
It also works on C programs, and in general, arbitrary executables.
We can compile the following normal C program, and run our decompiler on it.
\begin{lstlisting}[language=C]
int main() {
  int rc;
  rc = fork();
  if (rc == 0) {
    execlp("foo",
           "foo", "bar", "baz", NULL);
  } else { wait(NULL); }
  rc = fork();
  if (rc == 0) {
    execlp("whatever",
           "whatever", "quux", NULL);
  } else { wait(NULL); }
  return 0;
}
\end{lstlisting}
And we get the following shell script out:
\begin{lstlisting}[language=bash]
foo bar baz
whatever quux
\end{lstlisting}

Useful!

\subsection{Optimizing decompiler}
Our decompiler is so advanced that it in fact transparently applies optimizations in the process of decompilation.
Consider the following C program:
\begin{lstlisting}[language=C]
int main() {
  printf("hello world\n");
}
\end{lstlisting}
This program decompiles to the following shell script:
\begin{lstlisting}[language=bash]
\end{lstlisting}
Our decompiler correctly recognizes that this program,
since it doesn't execute any other programs from the filesystem,
is in fact utterly worthless, and optimizes it away to nothing.

\section{Implementation}\label{implementation}
Much to our surprise, we actually implemented this.

We have implemented a filesystem (using FUSE),
which pretends to have any possible executable you want.
We point the shell script at this filesystem using PATH,
and each time the shell script goes to run a command,
it instead runs a stub under our control.
Using some real technology we developed earlier and just thought it would be funny to use for this,
this stub connects back to the filesystem server,
where our decompiler is able to query its argv, stat its stdin/out/err, and tell it to exit with a specific exit code.

To mount the filesystem without requiring privileges or setuid executables,
we use a user namespace and mount namespace, and run the script inside those namespaces.

After the shell script finishes execution,
we reconstruct its source code from the trace of executed commands
using a highly advanced for loop.

Note that this doesn't use ``LD\_PRELOAD'' or strace,
so it can even be used on statically linked, setuid shell scripts.
There are lots of those!

The code is on Github at
\url{https://github.com/catern/rsyscall/tree/master/research/sigbovik2020}.

\section{Conclusion}\label{conclusion}
\subsection{Future work}
\subsubsection{Support for niche shell features}
There are some niche, minor features of the shell language which are not supported by our decompiler,
such as ``if'' and ``while''.
As any true shell programmer uses ``xargs'' instead,
which our framework would decompile just fine,
this isn't a problem.

Nevertheless it might be nice to figure out some ridiculous hack that would allow such features
(and shell builtins in general)
to be visible to our decompiler.

Maybe we could execute the shell script multiple times,
returning different exit codes from commands different times,
and thereby get a collection of traces through the control flow graph,
which we could then piece back together.
But this is beginning to sound like real work.
\subsection{Conclusion conclusion}
In conclusion,
we hope that this tool proves useful for maintenance shell programmers,
who will finally have a way to read those shell scripts that they always complain are unreadable.
Hopefully this will increase their productivity,
massively increase global GDP,
and cause my 401K to recover all the value it lost due to the coronavirus.

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
